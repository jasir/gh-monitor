#!/bin/bash

# GitHub Actions My Jobs Monitor
# Sleduje novÃ© joby spuÅ¡tÄ›nÃ© aktuÃ¡lnÃ­m uÅ¾ivatelem a automaticky je monitoruje

set -e

# Barvy
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# PomocnÃ© funkce
show_help() {
    echo "GitHub Actions My Jobs Monitor"
    echo "Sleduje bÄ›Å¾Ã­cÃ­ workflow runs aktuÃ¡lnÃ­ho uÅ¾ivatele a automaticky je monitoruje"
    echo ""
    echo "Usage: $0 [options]"
    echo ""
    echo "ğŸ¯ AutomatickÃ¡ detekce repozitÃ¡Å™e:"
    echo "  - PÅ™i spuÅ¡tÄ›nÃ­ z git repozitÃ¡Å™e automaticky detekuje GitHub repo z 'git remote'"
    echo "  - Sleduje pouze joby spuÅ¡tÄ›nÃ© aktuÃ¡lnÃ­m uÅ¾ivatelem"
    echo "  - Lze pÅ™epsat explicitnÃ­m zadÃ¡nÃ­m --repo"
    echo ""
    echo "Volby:"
    echo "  -i, --interval SEC  Interval kontroly v sekundÃ¡ch (vÃ½chozÃ­: 30)"
    echo "  -r, --repo REPO     Repository ve formÃ¡tu owner/repo"
    echo "                      Pokud nenÃ­ zadÃ¡no, detekuje z aktuÃ¡lnÃ­ho git repo"
    echo "  -q, --quiet         TichÃ½ reÅ¾im"
    echo "  -h, --help          ZobrazÃ­ tuto nÃ¡povÄ›du"
    echo ""
    echo "PÅ™Ã­klady:"
    echo "  # AutomatickÃ¡ detekce z aktuÃ¡lnÃ­ho adresÃ¡Å™e"
    echo "  cd ~/mÅ¯j-projekt && $0"
    echo ""
    echo "  # KonkrÃ©tnÃ­ repozitÃ¡Å™"
    echo "  $0 --repo KosikGroup/web-frontend"
    echo ""
    echo "  # RychlÃ© monitorovÃ¡nÃ­ s vlastnÃ­m intervalem"
    echo "  $0 --interval 15 --quiet"
    echo ""
    echo "ğŸ’¡ Tipy:"
    echo "  - SpusÅ¥te z adresÃ¡Å™e vaÅ¡eho projektu pro automatickou detekci"
    echo "  - Najde pouze joby, kterÃ© jste spustili vy"
    echo "  - IdeÃ¡lnÃ­ pro monitorovÃ¡nÃ­ CI/CD pÅ™i prÃ¡ci na features"
}

get_current_user() {
    gh api user --jq '.login' 2>/dev/null || echo ""
}

notify() {
    local title="$1"
    local message="$2"
    
    echo "ğŸ”” $title: $message"
    
    if command -v notify-send >/dev/null 2>&1 && [[ -n "$DISPLAY" ]]; then
        notify-send -t 8000 -u "normal" "$title" "$message" 2>/dev/null || true
    fi
}

detect_current_repo() {
    # ZkusÃ­ detekovat GitHub repozitÃ¡Å™ z git remote
    if [[ -d ".git" ]] || git rev-parse --git-dir >/dev/null 2>&1; then
        local remote_url
        remote_url=$(git remote get-url origin 2>/dev/null || echo "")
        
        if [[ -n "$remote_url" ]]; then
            # ParsovÃ¡nÃ­ GitHub URL (ssh nebo https) a odstranÄ›nÃ­ .git
            if [[ "$remote_url" =~ github\.com[:/]([^/]+)/([^/]+)(\.git)?$ ]]; then
                local repo_name="${BASH_REMATCH[2]}"
                repo_name="${repo_name%.git}"  # OdstranÄ›nÃ­ .git pokud existuje
                echo "${BASH_REMATCH[1]}/${repo_name}"
                return 0
            fi
        fi
    fi
    return 1
}

get_my_runs() {
    local repo="$1"
    local current_user
    
    # ZÃ­skÃ¡nÃ­ aktuÃ¡lnÃ­ho uÅ¾ivatele pro filtrovÃ¡nÃ­
    current_user=$(get_current_user)
    if [[ -z "$current_user" ]]; then
        echo "âŒ Nelze zÃ­skat aktuÃ¡lnÃ­ho uÅ¾ivatele" >&2
        return 1
    fi
    
    # AutomatickÃ¡ detekce repozitÃ¡Å™e, pokud nenÃ­ specifikovÃ¡n
    if [[ -z "$repo" ]]; then
        local detected_repo
        detected_repo=$(detect_current_repo)
        if [[ -n "$detected_repo" ]]; then
            echo "ğŸ” DetekovÃ¡n repozitÃ¡Å™: $detected_repo" >&2
            repo="$detected_repo"
        else
            echo "âŒ Å½Ã¡dnÃ½ repozitÃ¡Å™ nenÃ­ specifikovÃ¡n a nepodaÅ™ilo se detekovat z aktuÃ¡lnÃ­ho adresÃ¡Å™e" >&2
            echo "ğŸ’¡ PouÅ¾ijte --repo owner/repo nebo spusÅ¥te script z git repozitÃ¡Å™e" >&2
            return 1
        fi
    fi
    
    # Pro konkrÃ©tnÃ­ repozitÃ¡Å™ - zÃ­skÃ¡me vÅ¡echny bÄ›Å¾Ã­cÃ­ runs a filtrujeme podle uÅ¾ivatele
    local runs
    runs=$(gh run list --repo "$repo" --limit 50 --json databaseId,status,name,headBranch,event,createdAt \
        --jq ".[] | select(.status == \"in_progress\" or .status == \"queued\" or .status == \"waiting\")" 2>/dev/null)
    
    if [[ -n "$runs" ]]; then
        echo "$runs" | jq -r '.databaseId' | while read -r run_id; do
            if [[ -n "$run_id" ]]; then
                local actor
                actor=$(timeout 5 gh api "repos/$repo/actions/runs/$run_id" --jq '.actor.login' 2>/dev/null || echo "")
                if [[ "$actor" == "$current_user" ]]; then
                    echo "$runs" | jq "select(.databaseId == $run_id)"
                fi
            fi
        done
    fi
}

start_monitoring() {
    local run_id="$1"
    local repo="$2"
    local workflow_name="$3"
    
    local monitor_args=(
        "$run_id"
        "--interval" "5"
        "--timeout" "120"
    )
    
    [[ -n "$repo" ]] && monitor_args+=("--repo" "$repo")
    
    # SpuÅ¡tÄ›nÃ­ na pozadÃ­
    nohup gh-monitor "${monitor_args[@]}" > "/tmp/gh-monitor-${run_id}.log" 2>&1 &
    local pid=$!
    
    echo "$pid" > "/tmp/gh-monitor-${run_id}.pid"
    echo "ğŸš€ SpuÅ¡tÄ›n monitoring pro run $run_id (PID: $pid)"
    
    notify "ğŸ”„ NovÃ½ GitHub Action" "Workflow: $workflow_name\nRun ID: $run_id\nMonitoring spuÅ¡tÄ›n"
}

cleanup_all() {
    echo "ğŸ›¡ï¸  UkonÄuji vÅ¡echny monitory..."
    
    # UkonÄenÃ­ vÅ¡ech spouÅ¡tÄ›nÃ½ch gh-monitor procesÅ¯
    for pid_file in /tmp/gh-monitor-*.pid; do
        [[ -f "$pid_file" ]] || continue
        
        local pid=$(cat "$pid_file" 2>/dev/null || echo "")
        if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
            echo "  ğŸ“´ UkonÄuji monitor PID $pid"
            kill "$pid" 2>/dev/null || kill -9 "$pid" 2>/dev/null
        fi
        rm -f "$pid_file"
        
        local run_id=$(basename "$pid_file" .pid | sed 's/gh-monitor-//')
        rm -f "/tmp/gh-monitor-${run_id}.log"
        rm -f "/tmp/gh-monitor-${run_id}-waiting"
    done
    
    echo "ğŸ›¡ï¸  Cleanup dokonÄen"
}

cleanup_finished_monitors() {
    for pid_file in /tmp/gh-monitor-*.pid; do
        [[ -f "$pid_file" ]] || continue
        
        local pid=$(cat "$pid_file" 2>/dev/null || echo "")
        if [[ -n "$pid" ]] && ! kill -0 "$pid" 2>/dev/null; then
            rm -f "$pid_file"
            local run_id=$(basename "$pid_file" .pid | sed 's/gh-monitor-//')
            rm -f "/tmp/gh-monitor-${run_id}.log"
        fi
    done
}

main() {
    local interval=30
    local repo=""
    local quiet=false
    
    # ParsovÃ¡nÃ­ argumentÅ¯
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_help
                exit 0
                ;;
            -i|--interval)
                interval="$2"
                shift 2
                ;;
            -r|--repo)
                repo="$2"
                shift 2
                ;;
            -q|--quiet)
                quiet=true
                shift
                ;;
            *)
                echo "NeznÃ¡mÃ½ parametr: $1"
                exit 1
                ;;
        esac
    done
    
    # Kontrola zÃ¡vislostÃ­
    if ! command -v gh >/dev/null 2>&1; then
        echo "Chyba: GitHub CLI nenÃ­ nainstalovanÃ©"
        exit 1
    fi
    
    if ! command -v jq >/dev/null 2>&1; then
        echo "Chyba: jq nenÃ­ nainstalovanÃ©"
        exit 1
    fi
    
    if ! command -v gh-monitor >/dev/null 2>&1; then
        echo "Chyba: gh-monitor script nenÃ­ dostupnÃ½"
        exit 1
    fi
    
    if ! gh auth status >/dev/null 2>&1; then
        echo "Chyba: Nejste pÅ™ihlÃ¡Å¡eni do GitHub CLI"
        exit 1
    fi
    
    local current_user
    current_user=$(get_current_user)
    
    echo "ğŸ‘¤ SledovÃ¡nÃ­ jobÅ¯ pro uÅ¾ivatele: $current_user"
    
    # Detekce repozitÃ¡Å™e pro zobrazenÃ­
    local display_repo="$repo"
    if [[ -z "$display_repo" ]]; then
        display_repo=$(detect_current_repo 2>/dev/null || echo "")
        if [[ -n "$display_repo" ]]; then
            echo "ğŸ” DetekovÃ¡n repozitÃ¡Å™: $display_repo"
        else
            echo "âŒ Å½Ã¡dnÃ½ repozitÃ¡Å™ nebyl specifikovÃ¡n ani detekovÃ¡n"
            echo "ğŸ’¡ SpusÅ¥te z git repozitÃ¡Å™e nebo pouÅ¾ijte --repo owner/repo"
            exit 1
        fi
    else
        echo "ğŸ“ Repository: $display_repo"
    fi
    
    echo "â±ï¸  Interval: ${interval}s"
    echo "ğŸ” SledovÃ¡nÃ­ zaÄÃ­nÃ¡..."
    echo ""
    
    local check_count=0
    
    # HlavnÃ­ smyÄka
    while true; do
        check_count=$((check_count + 1))
        
        if [[ "$quiet" == false ]]; then
            echo "ğŸ“Š Kontrola #$check_count ($(date '+%H:%M:%S'))"
        fi
        
        # Cleanup ukonÄenÃ½ch monitorÅ¯
        cleanup_finished_monitors
        
        # ZÃ­skÃ¡nÃ­ bÄ›Å¾Ã­cÃ­ch jobÅ¯
        local my_runs
        if ! my_runs=$(get_my_runs "$repo" 2>/dev/null); then
            echo "âŒ Chyba pÅ™i zÃ­skÃ¡vÃ¡nÃ­ seznamu jobÅ¯"
            sleep "$interval"
            continue
        fi
        
        if [[ -n "$my_runs" ]]; then
            echo "$my_runs" | jq -r '. | "\(.databaseId)|\(.name)|\(.status)"' 2>/dev/null | while IFS='|' read -r run_id name status; do
                [[ -n "$run_id" ]] || continue
                
                # Kontrola, zda uÅ¾ nenÃ­ monitorovÃ¡n
                if [[ ! -f "/tmp/gh-monitor-${run_id}.pid" ]] && [[ ! -f "/tmp/gh-monitor-${run_id}-waiting" ]]; then
                    if [[ "$quiet" == false ]]; then
                        echo "  ğŸ†• NovÃ½ job: $name (ID: $run_id, Status: $status)"
                    fi
                    start_monitoring "$run_id" "$repo" "$name"
                elif [[ "$quiet" == false ]]; then
                    echo "  âœ… JiÅ¾ monitorovÃ¡n: $name (ID: $run_id)"
                fi
            done
        elif [[ "$quiet" == false ]]; then
            echo "  ğŸ’¤ Å½Ã¡dnÃ© bÄ›Å¾Ã­cÃ­ joby"
        fi
        
        if [[ "$quiet" == false ]]; then
            echo ""
        fi
        
        sleep "$interval"
    done
}

# ZpracovÃ¡nÃ­ signÃ¡lÅ¯ pro ÄistÃ© ukonÄenÃ­
trap 'cleanup_all; echo "ğŸš« UkonÄujem..."; exit 0' SIGINT SIGTERM

# SpuÅ¡tÄ›nÃ­
main "$@"