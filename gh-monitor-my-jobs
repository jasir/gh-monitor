#!/bin/bash

# GitHub Actions My Jobs Monitor
# Sleduje novÃ© joby spuÅ¡tÄ›nÃ© aktuÃ¡lnÃ­m uÅ¾ivatelem a automaticky je monitoruje

set -e

# Barvy
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# PomocnÃ© funkce
show_help() {
    echo "GitHub Actions My Jobs Monitor"
    echo ""
    echo "Usage: $0 [options]"
    echo ""
    echo "Volby:"
    echo "  -i, --interval SEC  Interval kontroly v sekundÃ¡ch (vÃ½chozÃ­: 30)"
    echo "  -r, --repo REPO     Repository ve formÃ¡tu owner/repo (vÃ½chozÃ­: vÅ¡echny)"
    echo "  -q, --quiet         TichÃ½ reÅ¾im"
    echo "  -h, --help          ZobrazÃ­ tuto nÃ¡povÄ›du"
    echo ""
    echo "PÅ™Ã­klady:"
    echo "  $0"
    echo "  $0 --interval 15"
    echo "  $0 --repo KosikGroup/web-frontend"
}

notify() {
    local title="$1"
    local message="$2"
    
    echo "ğŸ”” $title: $message"
    
    if command -v notify-send >/dev/null 2>&1 && [[ -n "$DISPLAY" ]]; then
        notify-send -t 8000 -u "normal" "$title" "$message" 2>/dev/null || true
    fi
}

get_current_user() {
    gh api user --jq '.login' 2>/dev/null || echo ""
}

get_my_runs() {
    local repo="$1"
    
    if [[ -n "$repo" ]]; then
        gh run list --repo "$repo" --limit 50 --json databaseId,status,name,headBranch,event,createdAt \
            --jq ".[] | select(.status == \"in_progress\" or .status == \"queued\" or .status == \"waiting\")"
    else
        # ZÃ­skÃ¡nÃ­ vÅ¡ech repozitÃ¡Å™Å¯ uÅ¾ivatele a organizacÃ­
        local repos=$(gh repo list --limit 100 --json nameWithOwner --jq '.[].nameWithOwner' 2>/dev/null)
        
        if [[ -n "$repos" ]]; then
            echo "$repos" | while read -r repo_name; do
                [[ -n "$repo_name" ]] && gh run list --repo "$repo_name" --limit 10 --json databaseId,status,name,headBranch,event,createdAt \
                    --jq ".[] | select(.status == \"in_progress\" or .status == \"queued\" or .status == \"waiting\")" 2>/dev/null || true
            done
        fi
    fi
}

start_monitoring() {
    local run_id="$1"
    local repo="$2"
    local workflow_name="$3"
    
    local monitor_args=(
        "$run_id"
        "--interval" "5"
        "--timeout" "120"
    )
    
    [[ -n "$repo" ]] && monitor_args+=("--repo" "$repo")
    
    # SpuÅ¡tÄ›nÃ­ na pozadÃ­
    nohup gh-monitor "${monitor_args[@]}" > "/tmp/gh-monitor-${run_id}.log" 2>&1 &
    local pid=$!
    
    echo "$pid" > "/tmp/gh-monitor-${run_id}.pid"
    echo "ğŸš€ SpuÅ¡tÄ›n monitoring pro run $run_id (PID: $pid)"
    
    notify "ğŸ”„ NovÃ½ GitHub Action" "Workflow: $workflow_name\nRun ID: $run_id\nMonitoring spuÅ¡tÄ›n"
}

cleanup_all() {
    echo "ğŸ›¡ï¸  UkonÄuji vÅ¡echny monitory..."
    
    # UkonÄenÃ­ vÅ¡ech spouÅ¡tÄ›nÃ½ch gh-monitor procesÅ¯
    for pid_file in /tmp/gh-monitor-*.pid; do
        [[ -f "$pid_file" ]] || continue
        
        local pid=$(cat "$pid_file" 2>/dev/null || echo "")
        if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
            echo "  ğŸ“´ UkonÄuji monitor PID $pid"
            kill "$pid" 2>/dev/null || kill -9 "$pid" 2>/dev/null
        fi
        rm -f "$pid_file"
        
        local run_id=$(basename "$pid_file" .pid | sed 's/gh-monitor-//')
        rm -f "/tmp/gh-monitor-${run_id}.log"
        rm -f "/tmp/gh-monitor-${run_id}-waiting"
    done
    
    echo "ğŸ›¡ï¸  Cleanup dokonÄen"
}

cleanup_finished_monitors() {
    for pid_file in /tmp/gh-monitor-*.pid; do
        [[ -f "$pid_file" ]] || continue
        
        local pid=$(cat "$pid_file" 2>/dev/null || echo "")
        if [[ -n "$pid" ]] && ! kill -0 "$pid" 2>/dev/null; then
            rm -f "$pid_file"
            local run_id=$(basename "$pid_file" .pid | sed 's/gh-monitor-//')
            rm -f "/tmp/gh-monitor-${run_id}.log"
        fi
    done
}

main() {
    local interval=30
    local repo=""
    local quiet=false
    
    # ParsovÃ¡nÃ­ argumentÅ¯
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_help
                exit 0
                ;;
            -i|--interval)
                interval="$2"
                shift 2
                ;;
            -r|--repo)
                repo="$2"
                shift 2
                ;;
            -q|--quiet)
                quiet=true
                shift
                ;;
            *)
                echo "NeznÃ¡mÃ½ parametr: $1"
                exit 1
                ;;
        esac
    done
    
    # Kontrola zÃ¡vislostÃ­
    if ! command -v gh >/dev/null 2>&1; then
        echo "Chyba: GitHub CLI nenÃ­ nainstalovanÃ©"
        exit 1
    fi
    
    if ! command -v jq >/dev/null 2>&1; then
        echo "Chyba: jq nenÃ­ nainstalovanÃ©"
        exit 1
    fi
    
    if ! command -v gh-monitor >/dev/null 2>&1; then
        echo "Chyba: gh-monitor script nenÃ­ dostupnÃ½"
        exit 1
    fi
    
    if ! gh auth status >/dev/null 2>&1; then
        echo "Chyba: Nejste pÅ™ihlÃ¡Å¡eni do GitHub CLI"
        exit 1
    fi
    
    echo "ğŸ‘¤ SledovÃ¡nÃ­ jobÅ¯ pro aktuÃ¡lnÃ­ho uÅ¾ivatele"
    [[ -n "$repo" ]] && echo "ğŸ“ Repository: $repo"
    echo "â±ï¸  Interval: ${interval}s"
    echo "ğŸ” SledovÃ¡nÃ­ zaÄÃ­nÃ¡..."
    echo ""
    
    local check_count=0
    
    # HlavnÃ­ smyÄka
    while true; do
        check_count=$((check_count + 1))
        
        if [[ "$quiet" == false ]]; then
            echo "ğŸ“Š Kontrola #$check_count ($(date '+%H:%M:%S'))"
        fi
        
        # Cleanup ukonÄenÃ½ch monitorÅ¯
        cleanup_finished_monitors
        
        # ZÃ­skÃ¡nÃ­ bÄ›Å¾Ã­cÃ­ch jobÅ¯
        local my_runs
        if ! my_runs=$(get_my_runs "$repo" 2>/dev/null); then
            echo "âŒ Chyba pÅ™i zÃ­skÃ¡vÃ¡nÃ­ seznamu jobÅ¯"
            sleep "$interval"
            continue
        fi
        
        if [[ -n "$my_runs" ]]; then
            echo "$my_runs" | jq -r '. | "\(.databaseId)|\(.name)|\(.status)"' 2>/dev/null | while IFS='|' read -r run_id name status; do
                [[ -n "$run_id" ]] || continue
                
                # Kontrola, zda uÅ¾ nenÃ­ monitorovÃ¡n
                if [[ ! -f "/tmp/gh-monitor-${run_id}.pid" ]] && [[ ! -f "/tmp/gh-monitor-${run_id}-waiting" ]]; then
                    if [[ "$quiet" == false ]]; then
                        echo "  ğŸ†• NovÃ½ job: $name (ID: $run_id, Status: $status)"
                    fi
                    start_monitoring "$run_id" "$repo" "$name"
                elif [[ "$quiet" == false ]]; then
                    echo "  âœ… JiÅ¾ monitorovÃ¡n: $name (ID: $run_id)"
                fi
            done
        elif [[ "$quiet" == false ]]; then
            echo "  ğŸ’¤ Å½Ã¡dnÃ© bÄ›Å¾Ã­cÃ­ joby"
        fi
        
        if [[ "$quiet" == false ]]; then
            echo ""
        fi
        
        sleep "$interval"
    done
}

# ZpracovÃ¡nÃ­ signÃ¡lÅ¯ pro ÄistÃ© ukonÄenÃ­
trap 'cleanup_all; echo "ğŸš« UkonÄujem..."; exit 0' SIGINT SIGTERM

# SpuÅ¡tÄ›nÃ­
main "$@"